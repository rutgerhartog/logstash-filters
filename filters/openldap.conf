# The filter is set to stdin for testing purposes
input {
  stdin { }
}



filter {
  grok {
    match => [ "message", "%{WORD:id} (?:(?:<= (?:b|m)db_%{DATA:index_error_filter_type}_candidates: \(%{WORD:index_error_attribute_name}\) not indexed)|(?:ppolicy_%{DATA:ppolicy_op}: %{DATA:ppolicy_data})|(?:connection_input: conn=%{INT:connection} deferring operation: %{DATA:deferring_op})|(?:connection_read\(%{INT:fd_number}\): no connection!)|(?:conn=%{INT:connection} (?:(?:fd=%{INT:fd_number} (?:(?:closed(?: \(connection lost\)|))|(?:ACCEPT from IP=%{IP:src_ip}\:%{INT:src_port} \(IP=%{IP:dst_ip}\:%{INT:dst_port}\))|(?:TLS established tls_ssf=%{INT:tls_ssf} ssf=%{INT:ssf})))|(?:op=%{INT:operation_number} (?:(?:(?:(?:SEARCH )|(?:))RESULT (?:tag=%{INT:tag}|oid=(?:%{DATA:oid}(?:))) err=%{INT:error_code}(?:(?: nentries=%{INT:nentries})|(?:)) text=(?:(?:%{DATA:error_text})|(?:)))|(?:%{WORD:operation_name}(?:(?: %{DATA:data})|(?:))))))))%{SPACE}$"]
  }
  date {
    locale => "en"
    match => [ "timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss", "ISO8601" ]
    target => "@timestamp"
  }
  if [src_ip] {
    aggregate {
      task_id => "%{connection}"
      code => "
      map['src_ip'] = event.get('src_ip')
      map['src_port'] = event.get('src_port')
      map['dst_ip'] = event.get('dst_ip')
      map['dst_port'] = event.get('dst_port')
      "
    }
  }
  if [operation_name] == "BIND" {
    grok {
      match => [ "data", "(?:(?:(?<bind_dn>anonymous))|(?:dn=\"%{DATA:bind_dn}\")) (?:(?:method=%{WORD:bind_method})|(?:mech=%{WORD:bind_mech} ssf=%{INT:bind_ssf}))%{SPACE}$" ]
      remove_field => [ "data" ]
      }
    aggregate {
      task_id => "%{connection}"
      code => "
      map['actions'] = {}
      "
    }
    if [bind_mech] {
      aggregate {
        task_id => "%{connection}"
        code => "
        map['bind_dn'] = event.get('bind_dn')
        map['bind_mech'] = event.get('bind_mech')
        map['bind_ssf'] = event.get('bind_ssf')
        "
      }
    }
    if [bind_method] {
      aggregate {
        task_id => "%{connection}"
        code => "
        map['bind_method'] = event.get('bind_method')
        "
      }
    }
  }
  if [operation_name] == "SRCH" {
    grok {
      match => [ "data", "(?:(?:base=\"%{DATA:search_base}\" scope=%{INT:search_scope} deref=%{INT:search_deref} filter=\"%{DATA:search_filter}\")|(?:attr=%{DATA:search_attr}))%{SPACE}$" ]
      remove_field => [ "data" ]
    }
    if [search_filter] {
      aggregate {
        task_id => "%{connection}"
        code => "
        map['actions'] ||= {}
        map['actions'][event.get('operation_number')] = {
        'operation_name': event.get('operation_name'),
        'search_filter': event.get('search_filter')
        }
        "
      }
    }
    if [search_attr] {
      aggregate {
        task_id => "%{connection}"
        code => "
        map['actions'] ||= {}
        map['actions'][event.get('operation_number')] ||= {}
        map['actions'][event.get('operation_number')]['search_attr'] = event.get('search_attr')
        "
      }
    }
  }
  if [operation_name] == "MOD" {
    grok {
      match => [ "data", "(?:(?:dn=\"%{DATA:mod_dn}\")|(?:attr=%{DATA:mod_attr}))%{SPACE}$" ]
      remove_field => [ "data" ]
    }
    if [mod_dn] {
      aggregate {
        task_id => "%{connection}"
        code => "
        map['actions'] ||= {}
        map['actions'][event.get('operation_number')] ||= {}
        map['actions'][event.get('operation_number')]['mod_dn'] = event.get('mod_dn')
        "
      }
    }
    else {
    aggregate {
      task_id => "%{connection}"
      code => "
      map['actions'] ||= {}
      map['actions'][event.get('operation_number')] ||= {}
      map['actions'][event.get('operation_number')]['mod_attr'] = event.get('mod_attr')
      "
    }
    }
  }
  if [operation_name] == "MODRDN" {
    grok {
      match => [ "data", "dn=\"%{DATA:modrdn_dn}\"%{SPACE}$" ]
      remove_field => [ "data" ]
    }
    aggregate {
      task_id => "%{connection}"
      code => "
      map['actions'] ||= {}
      map['actions'][event.get('operation_number')] ||= {}
      map['actions'][event.get('operation_number')]['modrdn_dn'] = event.get('modrdn_dn')
      "
    }
  }
  if [operation_name] == "ADD" {
    grok {
      match => [ "data", "dn=\"%{DATA:add_dn}\"%{SPACE}$" ]
      remove_field => [ "data" ]
    }
    aggregate {
      task_id => "%{connection}"
      code => "
      map['actions'] ||= {}
      map['actions'][event.get('operation_number')] ||= {}
      map['actions'][event.get('operation_number')]['add_dn'] = event.get('add_dn')
      "
    }
  }
  if [operation_name] == "DEL" {
    grok {
      match => [ "data", "dn=\"%{DATA:del_dn}\"%{SPACE}$" ]
      remove_field => [ "data" ]
    }
    aggregate {
      task_id => "%{connection}"
      code => "
      map['actions'] ||= {}
      map['actions'][event.get('operation_number')] ||= {}
      map['actions'][event.get('operation_number')]['del_dn'] = event.get('del_dn')
      "
    }
  }
  if [operation_name] == "CMP" {
    grok {
      match => [ "data", "dn=\"%{DATA:cmp_dn}\" attr=\"%{DATA:cmp_attr}\"%{SPACE}$" ]
      remove_field => [ "data" ]
    }
    aggregate {
      task_id => "%{connection}"
      code => "
      map['actions'] ||= {}
      map['actions'][event.get('operation_number')] ||= {}
      map['actions'][event.get('operation_number')]['cmp_dn'] = event.get('cmp_dn')
      map['actions'][event.get('operation_number')]['cmp_attr'] = event.get('cmp_attr')
      "
    }
  }
  if [operation_name] == "EXT" {
    grok {
      match => [ "data", "oid=%{DATA:ext_oid}%{SPACE}$" ]
      remove_field => [ "data" ]
    }
    aggregate {
      task_id => "%{connection}"
      code => "
      map['actions'] ||= {}
      map['actions'][event.get('operation_number')] ||= {}
      map['actions'][event.get('operation_number')]['ext_oid'] = event.get('ext_oid')
      "
    }
  }
  if [ppolicy_op] == "bind" {
    grok {
      match => [ "ppolicy_data", "(?:(?:Entry %{DATA:ppolicy_bind_dn} has an expired password: %{INT:ppolicy_grace} grace logins)|(?:Setting warning for password expiry for %{DATA:ppolicy_bind_dn} = %{INT:ppolicy_expiration} seconds))%{SPACE}$" ]
      remove_field => [ "ppolicy_data" ]
    }
    aggregate {
      task_id => "%{connection}"
      code => "
      map['actions'] ||= {}
      map['actions'][event.get('operation_number')] ||= {}
      map['actions'][event.get('operation_number')]['ppolicy_bind_dn'] = event.get('ppolicy_bind_dn')
      "
    }
  }
  if [nentries] {
    aggregate {
      task_id => "%{connection}"
      code => "
      ldap_codes = {
        '0': 'LDAP_SUCCESS',
        '1': 'LDAP_OPERATIONS_ERROR',
        '2': 'LDAP_PROTOCOL_ERROR',
        '3': 'LDAP_TIMELIMIT_EXCEEDED',
        '4': 'LDAP_SIZELIMIT_EXCEEDED',
        '5': 'LDAP_COMPARE_FALSE',
        '6': 'LDAP_COMPARE_TRUE',
        '7': 'LDAP_AUTH_METHOD_NOT_SUPPORTED',
        '8': 'LDAP_STRONG_AUTH_REQUIRED',
        '9': 'INVALID_ERROR',
        '10': 'LDAP_REFERRAL',
        '11': 'LDAP_ADMINLIMIT_EXCEEDED',
        '12': 'LDAP_UNAVAILABLE_CRITICAL_EXTENSION',
        '13': 'LDAP_CONFIDENTIALITY_REQUIRED',
        '14': 'LDAP_SASL_BIND_IN_PROGRESS',
        '15': 'INVALID_ERROR',
        '16': 'LDAP_NO_SUCH_ATTRIBUTE',
        '17': 'LDAP_UNDEFINED_TYPE',
        '18': 'LDAP_INAPPROPRIATE_MATCHING',
        '19': 'LDAP_CONSTRAINT_VIOLATION',
        '20': 'LDAP_TYPE_OR_VALUE_EXISTS',
        '21': 'LDAP_INVALID_SYNTAX',
        '32': 'LDAP_NO_SUCH_OBJECT',
        '33': 'LDAP_ALIAS_PROBLEM',
        '34': 'LDAP_INVALID_DN_SYNTAX',
        '35': 'LDAP_IS_LEAF',
        '36': 'LDAP_ALIAS_DEREF_PROBLEM',
        '48': 'LDAP_INAPPROPRIATE_AUTH',
        '49': 'LDAP_INVALID_CREDENTIALS',
        '50': 'LDAP_INSUFFICIENT_ACCESS',
        '51': 'LDAP_BUSY',
        '52': 'LDAP_UNAVAILABLE',
        '53': 'LDAP_UNWILLING_TO_PERFORM',
        '54': 'LDAP_LOOP_DETECT',
        '64': 'LDAP_NAMING_VIOLATION',
        '65': 'LDAP_OBJECT_CLASS_VIOLATION',
        '66': 'LDAP_NOT_ALLOWED_ON_NONLEAF',
        '67': 'LDAP_NOT_ALLOWED_ON_RDN',
        '68': 'LDAP_ALREADY_EXISTS',
        '69': 'LDAP_NO_OBJECT_CLASS_MODS',
        '70': 'LDAP_RESULTS_TOO_LARGE',
        '71': 'LDAP_AFFECTS_MULTIPLE_DSAS',
        '80': 'LDAP_OTHER',
        '81': 'LDAP_SERVER_DOWN',
        '82': 'LDAP_LOCAL_ERROR',
        '83': 'LDAP_ENCODING_ERROR',
        '84': 'LDAP_DECODING_ERROR',
        '85': 'LDAP_TIMEOUT',
        '86': 'LDAP_AUTH_UNKNOWN',
        '87': 'LDAP_FILTER_ERROR',
        '88': 'LDAP_USER_CANCELLED',
        '89': 'LDAP_PARAM_ERROR',
        '90': 'LDAP_NO_MEMORY',
        '91': 'LDAP_CONNECT_ERROR',
        '92': 'LDAP_NOT_SUPPORTED',
        '93': 'LDAP_CONTROL_NOT_FOUND',
        '94': 'LDAP_NO_RESULTS_RETURNED',
        '95': 'LDAP_MORE_RESULTS_TO_RETURN',
        '96': 'LDAP_CLIENT_LOOP',
        '97': 'LDAP_REFERRAL_LIMIT_EXCEEDED',
        '100': 'INVALID_RESPONSE',
        '101': 'AMBIGUOUS_RESPONSE',
        '112': 'TLS_NOT_SUPPORTED',
        '113': 'lcupResourcesExhausted',
        '114': 'lcupSecurityViolation',
        '115': 'lcupInvalidData',
        '116': 'lcupUnsupportedScheme',
        '117': 'lcupReloadRequired',
        '118': 'canceled',
        '119': 'noSuchOperation',
        '120': 'tooLate',
        '121': 'cannotCancel',
        '122': 'assertionFailed',
        '123': 'authorizationDenied'
      }
      map['actions'] ||= {}
      map['actions'][event.get('operation_number')] ||= {}
      map['actions'][event.get('operation_number')]['result_tag'] = event.get('tag')
      map['actions'][event.get('operation_number')]['result_entries'] = event.get('nentries')
      map['actions'][event.get('operation_number')]['result_error_code'] = event.get('error_code')
      map['actions'][event.get('operation_number')]['result_error_code_meaning'] = ldap_codes[event.get('error_code').to_sym]
      "
    }
  }

  aggregate {
    task_id => "%{connection}"
    code => "
    "
    push_map_as_event_on_timeout => true
    timeout_task_id_field => "connection"
    timeout => 5
    timeout_tags => ['_aggregatetimeout']
    }

  if ![actions] {
    drop {}
  }
}
output {
  stdout {
    codec => rubydebug
  }
}
